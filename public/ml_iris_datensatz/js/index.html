<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <title>Iris – TensorFlow.js Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- tf.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 1rem;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            color: white;
        }

        .title {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .section {
            margin-bottom: 1.5rem;
        }

        .log {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            white-space: pre-line;
            max-height: 100px;
            overflow-y: auto;
            color: #495057;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
            align-items: center;
        }

        label {
            font-weight: 500;
            color: #495057;
        }

        input {
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        .actions {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .mono {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .pill {
            background: #e9ecef;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 0.5rem;
            color: #495057;
        }

        .footer {
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.4;
        }

        .warn {
            color: #fd7e14;
            font-weight: 500;
        }

        .kpi {
            color: #28a745;
            font-weight: 500;
        }

        h3 {
            color: #495057;
            margin-bottom: 1rem;
        }

        @media (max-width: 600px) {
            .title {
                font-size: 2rem;
            }

            .grid {
                grid-template-columns: 1fr;
            }

            .actions {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header class="header">
            <h1 class="title">Iris – Klassifikation (tf.js)</h1>
        </header>

        <section class="card section">
            <div id="log" class="log">Lade Daten…</div>
        </section>

        <section class="card section">
            <h3 style="margin:.2rem 0 1rem">Vorhersage</h3>
            <div class="grid">
                <label for="sl">Sepal length (cm)</label><input id="sl" type="number" step="0.1" value="5.1">
                <label for="sw">Sepal width (cm)</label><input id="sw" type="number" step="0.1" value="3.5">
                <label for="pl">Petal length (cm)</label><input id="pl" type="number" step="0.1" value="1.4">
                <label for="pw">Petal width (cm)</label><input id="pw" type="number" step="0.1" value="0.2">
            </div>
            <p class="actions">
                <button id="predictBtn" disabled>Vorhersagen</button>
                <span id="predOut" class="mono"></span>
            </p>
            <p class="footer">Tipp: Nach dem Training oben erscheinen Loss/Accuracy-Logs. <span
                    class="warn">Validation</span> & <span class="kpi">Test</span> werden getrennt berechnet.</p>
        </section>
    </div>

    <script>
        const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');

        async function initializeTensorFlow() {
            const logEl = document.getElementById('log');
            const log = (s) => { logEl.textContent += (logEl.textContent ? '\n' : '') + s; };

            try {
                await tf.ready();

                if (isFirefox) {
                    log('Firefox erkannt - verwende CPU-Backend für Stabilität...');
                    await tf.setBackend('cpu');
                    await tf.ready();
                    log(`Backend: ${tf.getBackend()}`);
                } else {
                    log(`Browser: ${navigator.userAgent.split(' ').pop()}`);
                    log(`Initial Backend: ${tf.getBackend()}`);

                    if (tf.getBackend() === 'webgl') {
                        try {
                            const test = tf.tensor1d([1, 2, 3]);
                            const result = test.square();
                            await result.data();
                            result.dispose();
                            test.dispose();
                            log('WebGL funktioniert');
                        } catch (e) {
                            log('WebGL-Problem erkannt, wechsle zu CPU...');
                            await tf.setBackend('cpu');
                            await tf.ready();
                            log(`Neues Backend: ${tf.getBackend()}`);
                        }
                    }
                }

                await runMLDemo(log);

            } catch (error) {
                log('Kritischer Fehler beim TensorFlow.js Setup: ' + error.message);
                console.error('TensorFlow.js Fehler:', error);

                try {
                    log('Versuche Notfall-CPU-Backend...');
                    await tf.setBackend('cpu');
                    await tf.ready();
                    await runMLDemo(log);
                } catch (fallbackError) {
                    log('Auch CPU-Backend fehlgeschlagen: ' + fallbackError.message);
                }
            }
        }

        async function runMLDemo(log) {
            const predictBtn = document.getElementById('predictBtn');
            const predOut = document.getElementById('predOut');
            const inputs = ['sl', 'sw', 'pl', 'pw'].map(id => document.getElementById(id));

            const LABELS = ['setosa', 'versicolor', 'virginica'];
            const CSV_URL = 'https://kado-ber.de/ml_iris_datensatz/js/iris.csv';

            const csvToArrays = (csvText) => {
                const lines = csvText.trim().split(/\r?\n/);
                const header = lines.shift().split(',');
                const speciesIdx = header.indexOf('species');
                const X = [], y = [];
                for (const line of lines) {
                    const cols = line.split(',');
                    X.push([+cols[0], +cols[1], +cols[2], +cols[3]]);
                    y.push(cols[speciesIdx]);
                }
                return { X, y };
            }
            const labelToIndex = s => LABELS.indexOf(s);

            // 1) Daten laden
            log('Lade Iris-Datensatz...');
            const res = await fetch(CSV_URL);
            const txt = await res.text();
            const { X, y } = csvToArrays(txt);
            log(`${X.length} Datenpunkte geladen`);

            // 2) Shuffle + Train/Test Split
            const idx = X.map((_, i) => i);
            for (let i = idx.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [idx[i], idx[j]] = [idx[j], idx[i]];
            }
            const Xs = idx.map(i => X[i]);
            const ys = idx.map(i => labelToIndex(y[i]));
            const nTrain = Math.floor(0.8 * Xs.length);

            const Xtrain = Xs.slice(0, nTrain);
            const ytrain = ys.slice(0, nTrain);
            const Xtest = Xs.slice(nTrain);
            const ytest = ys.slice(nTrain);

            log(`Training: ${Xtrain.length}, Test: ${Xtest.length}`);

            // 3) Normalisieren
            const xTrainTf = tf.tensor2d(Xtrain);
            const xTestTf = tf.tensor2d(Xtest);

            const mean = xTrainTf.mean(0);
            const std = xTrainTf.sub(mean).square().mean(0).sqrt().add(tf.scalar(1e-8));

            const xTr = xTrainTf.sub(mean).div(std);
            const yTr = tf.tensor1d(ytrain);
            const xTe = xTestTf.sub(mean).div(std);
            const yTe = tf.tensor1d(ytest);

            // 4) Einfaches, stabiles Modell
            const model = tf.sequential();
            model.add(tf.layers.dense({
                units: 12,
                activation: 'relu',
                inputShape: [4],
                kernelInitializer: 'glorotUniform'
            }));
            model.add(tf.layers.dense({
                units: 8,
                activation: 'relu',
                kernelInitializer: 'glorotUniform'
            }));
            model.add(tf.layers.dense({
                units: 3,
                activation: 'softmax',
                kernelInitializer: 'glorotUniform'
            }));

            model.compile({
                optimizer: tf.train.adam(0.008),
                loss: 'sparseCategoricalCrossentropy',
                metrics: ['accuracy']
            });

            // 5) Training mit kleinen Batches
            log('Training startet...');
            const startTime = Date.now();

            await model.fit(xTr, yTr, {
                epochs: 100,
                batchSize: 8,
                shuffle: true,
                validationSplit: 0.2,
                verbose: 0,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        if (epoch % 15 === 0 || epoch === 99) {
                            const lossStr = logs.loss ? logs.loss.toFixed(3) : 'N/A';
                            const accStr = logs.acc ? logs.acc.toFixed(3) : 'N/A';
                            log(`Epoch ${String(epoch + 1).padStart(3)} — loss ${lossStr} — acc ${accStr}`);
                        }
                    }
                }
            });

            const trainTime = ((Date.now() - startTime) / 1000).toFixed(1);
            log(`Training abgeschlossen (${trainTime}s)`);

            // 6) Test-Evaluierung
            const evalResult = model.evaluate(xTe, yTe, { batchSize: 8, verbose: 0 });
            const testLoss = await evalResult[0].data();
            const testAcc = await evalResult[1].data();

            log(`Test — loss ${testLoss[0].toFixed(3)} — accuracy ${(testAcc[0] * 100).toFixed(1)}%`);

            // Cleanup evaluation tensors
            evalResult.forEach(t => t.dispose());

            // 7) Vorhersage aktivieren
            predictBtn.disabled = false;
            predictBtn.addEventListener('click', () => {
                const vals = inputs.map(el => parseFloat(el.value));
                if (vals.some(v => Number.isNaN(v))) {
                    predOut.innerHTML = '<span style="color: #dc3545;">Bitte alle Werte eingeben</span>';
                    return;
                }

                const prediction = tf.tidy(() => {
                    const x = tf.tensor2d([vals]).sub(mean).div(std);
                    const probs = model.predict(x);
                    return probs.dataSync();
                });

                const best = prediction.reduce((bi, p, i) => (p > prediction[bi] ? i : bi), 0);
                const pretty = LABELS.map((lab, i) =>
                    `${lab}<span class="pill">${(prediction[i] * 100).toFixed(1)}%</span>`
                ).join('  ');
                predOut.innerHTML = `→ <strong>${LABELS[best]}</strong>  |  ${pretty}`;
            });

            const cleanup = () => {
                try {
                    [xTrainTf, xTestTf, xTr, yTr, xTe, yTe, mean, std].forEach(t => {
                        if (t && !t.isDisposed) t.dispose();
                    });
                    if (model) model.dispose();
                } catch (e) {
                    console.warn('Cleanup warning:', e);
                }
            };

            window.addEventListener('beforeunload', cleanup);
            log('Fertig! Vorhersage verfügbar.');
        }

        document.addEventListener('DOMContentLoaded', () => {
            initializeTensorFlow().catch(error => {
                console.error('Startup error:', error);
                document.getElementById('log').textContent = 'Fehler beim Start: ' + error.message;
            });
        });
    </script>
</body>

</html>